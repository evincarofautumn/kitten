// Whether all elements of a vector satisfy a predicate.
def all ([a] (a -> Bool) -> Bool):
  map and

// Appends a value to the end of a vector.
def append ([a] a -> [a]):
  vector cat

// The Cartesian product of two vectors.
def cartesian ([a] [b] -> [(a, b)]):
  {double} cartesianWith

// The Cartesian product of two vectors with a
// generalized tupling function.
def cartesianWith ([a] [b] (a b -> c) -> [c]):
  -> { xs ys fn }
  xs { ys length replicate } mapConcat -> xs2
  ys xs length replicate concat -> ys2
  xs2 ys2 fn zipWith

// Concatenates a vector of vectors.
def concat ([[a]] -> [a]):
  [] {cat} fold

// Constructs a 2-tuple.
def double (a b -> (a, b)):
  -> { a b }
  (a, b)

// Filters a vector by a predicate.
def filter ([a] (a -> Bool) -> [a]):
  -> { v f }
  if v empty then:
    v
  else if v head f apply11 then:
    v tail f filter
    v head prepend
  else:
    v tail f filter

// Gets the first element of a tuple or pair.
def first ((a & b) -> a):
  __first

// Flips the elements of a double.
def flip ((a, b) -> (b, a)):
  -> d
  d first -> a
  d second -> b
  (b, a)

// Folds elements of a vector right-associatively.
def foldr ([a] b (a b -> b) -> b):
  -> { xs z k }
  if xs empty then:
    z
  else:
    xs head
    xs tail z k foldr
    k apply21

// Folds elements of a vector left-associatively.
def fold ([b] a (a b -> a) -> a):
  -> { xs z k }
  if xs empty then:
    z
  else:
    xs tail
    z xs head k apply21
    k fold

// Gets the fourth element of a tuple.
def fourth ((a & b & c & d & e) -> d):
  rest rest rest first

// Gets a value from a 2D vector.
def get2 ([[a]] Int Int -> a):
  -> { i j }
  i get j get

// Gets the first element of a vector.
def head ([a] -> a):
  __head

// Iterates a function on a value until a predicate holds.
def until (a (a -> a) (a -> Bool) -> a):
  -> { x f p }
  if x p apply11 then:
    x
  else:
    x f apply11
    f p until

// Keeps the first n elements of a vector, tossing the rest.
def keep ([a] Int -> [a]):
  -> { xs n }
  if n 0 <=  xs empty  || then:
    []
  else:
    xs tail n-- keep
    xs head prepend

// Lifts a function on values to a function on vectors.
def map ([a] (a -> b) -> [b]):
  -> { xs f }
  if xs empty then:
    []
  else:
    xs tail f map
    xs head f apply11
    prepend

// Maps a function over a value for each integer in a range.
def mapRange (a (a Int -> a) Int Int -> a):
  -> { value function start end }
  if start end <= then:
    value start function apply21
    function start++ end mapRange
  else:
    value

// Maps a function over an element of a vector.
def modify ([a] (a -> a) Int -> [a]):
  -> { vec function offset }
  vec offset get function apply11 -> value
  vec value offset set

// Maps a function over part of a vector.
def mapFrom ([a] (a -> a) Int -> [a]):
  -> { vec function offset }
  if vec empty  offset vec length >=  || then:
    vec
  else:
    vec function offset modify
    function offset++ mapFrom

// Maps an impure function over each element of a vector.
def each ([a] (a ->) ->):
  -> f
  { dup f apply10 } map
  drop

// Produces a vector with some number of copies of a value.
def replicate (a Int -> [a]):
  -> { value count }
  if count 0 <= then:
    []
  else:
    value count-- replicate
    value prepend

// Gets the second element of a pair or the tail of a tuple.
def rest ((a & b) -> b):
  __rest

// Reverses a vector.
def reverse ([a] -> [a]):
  -> xs
  if xs empty then:
    []
  else:
    xs init reverse
    xs last prepend

// Gets the second element of a tuple.
def second ((a & b & c) -> b):
  rest first

// Sets a value in a 2D vector.
def set2 ([[a]] a Int Int -> [[a]]):
  -> { x i j }
  { x j set } i modify

// Splits a vector into two parts at the given index.
def splitAt ([a] Int -> [a] [a]):
  -> { xs n }
  xs n toss
  xs n keep

// Gets the third element of a tuple.
def third ((a & b & c & d) -> c):
  rest rest first

// Tosses the first n elements of a vector, keeping the rest.
def toss ([a] Int -> [a]):
  -> { xs n }
  if n 0 <=  xs empty  || then:
    xs
  else:
    xs tail n-- toss

// Logical NOT.
def ! (Bool -> Bool):
  __not_bool

// Integer inequality.
def != (Int Int -> Bool):
  __ne_int

// Floating-point inequality.
def !=. (Float Float -> Bool):
  __ne_float

// Integer modulus.
def % (Int Int -> Int):
  __mod_int

// Floating-point modulus.
def %. (Float Float -> Float):
  __mod_float

// Bitwise AND.
def & (Int Int -> Int):
  __and_int

// Logical AND.
def && (Bool Bool -> Bool):
  __and_bool

// Integer multiplication.
def * (Int Int -> Int):
  __mul_int

// Floating-point multiplication.
def *. (Float Float -> Float):
  __mul_float

// Integer addition.
def + (Int Int -> Int):
  __add_int

// Integer increment.
def ++ (Int -> Int):
  __inc_int

// Floating-point increment.
def ++. (Float -> Float):
  __inc_float

// Floating-point addition.
def +. (Float Float -> Float):
  __add_float

// Integer subtraction.
def - (Int Int -> Int):
  __sub_int

// Integer decrement.
def -- (Int -> Int):
  __dec_int

// Floating-point decrement.
def --. (Float -> Float):
  __dec_float

// Floating-point subtraction.
def -. (Float Float -> Float):
  __sub_float

// Integer division.
def / (Int Int -> Int):
  __div_int

// Floating-point division.
def /. (Float Float -> Float):
  __div_float

// Integer less than.
def < (Int Int -> Bool):
  __lt_int

// Floating-point less than.
def <. (Float Float -> Bool):
  __lt_float

// Integer less than or equal.
def <= (Int Int -> Bool):
  __le_int

// Floating-point less than or equal.
def <=. (Float Float -> Bool):
  __le_float

// Integer equality.
def = (Int Int -> Bool):
  __eq_int

// Floating-point equality.
def =. (Float Float -> Bool):
  __eq_float

// Integer greater than.
def > (Int Int -> Bool):
  __gt_int

// Floating-point greater than.
def >. (Float Float -> Bool):
  __gt_float

// Integer greater than or equal.
def >= (Int Int -> Bool):
  __ge_int

// Floating-point greater than or equal.
def >=. (Float Float -> Bool):
  __ge_float

// Bitwise XOR.
def ^ (Int Int -> Int):
  __xor_int

// Boolean XOR.
def ^^ (Bool Bool -> Bool):
  __xor_bool

// Whether all elements of a vector are true.
def and ([Bool] -> Bool):
  true {&&} fold

// Whether any element of a vector satisfies a predicate.
def any ([a] (a -> Bool) -> Bool):
  map or

// Applies a nullary function with one result.
def apply01 ((-> a) -> a):
  __apply01

// Applies a unary function with no results.
def apply10 (a (a ->) ->):
  __apply10

// Applies a unary function with one result.
def apply11 (a (a -> b) -> b):
  __apply11

def apply21 (a b (a b -> c) -> c):
  __apply21

// Concatenates two vectors.
def cat ([a] [a] -> [a]):
  __add_vector

// Composes two unary functions with one result.
def compose ((a -> b) (b -> c) -> (a -> c)):
  -> { f g }
  { f apply11 g apply11 }

// Wraps a value in a function.
def const (a -> (b -> a)):
  -> x
  { drop x }

// Drops a value.
def drop (a ->):
  -> x

// Duplicates a value.
def dup (a -> a a):
  -> x
  x x

// Whether a character is present in a string.
def elemc ([Char] Char -> Bool):
  -> x
  { x eqc } any

// Whether an integer is present in an integer vector.
def elemi ([Int] Int -> Bool):
  -> x
  { x = } any

// Whether a vector is empty.
def empty ([a] -> Bool):
  length 0 =

// Character equality.
def eqc (Char Char -> Bool):
  __eq_char

// String equality.
def eqcv ([Char] [Char] -> Bool):
  {eqc} eqv

// Integer vector equality.
def eqiv ([Int] [Int] -> Bool):
  {=} eqv

def equ (() () -> Bool):
  drop drop true

def eqv ([a] [a] (a a -> Bool) -> Bool):
  -> { xs ys eq }
  if xs empty ys empty && then:
    true
  else if xs head ys head eq apply21 then:
    xs tail ys tail eq eqv
  else:
    false

// Whether a floating-point number is even.
def evenf (Float -> Bool):
  2.0 %. 0.0 =.

// Whether an integer is even.
def eveni (Int -> Bool):
  2 % 0 =

def exit (Int ->):
  __exit

// Character greater than or equal.
def gec (Char Char -> Bool):
  __ge_char

// Gets an element of a vector.
def get ([a] Int -> a):
  __get

// Reads a line from standard input.
def getLine (-> [Char]):
  stdin __get_line

// Character greater than.
def gtc (Char Char -> Bool):
  __gt_char

// Closes a handle.
def handleClose (Handle ->):
  __close

// Reads a line from a handle.
def handleGetLine (Handle -> [Char]):
  __get_line

// Writes a string to a handle.
def handlePrint ([Char] Handle ->):
  __print

// Identity function.
def id (a -> a):
  -> x
  x

// Removes the last element of a vector.
def init ([a] -> [a]):
  __init

// Joins a vector with a separator.
def join ([[a]] [a] -> [a]):
  intersperse concat

// Intersperses a value between the values of a vector.
def intersperse ([a] a -> [a]):
  -> { xs sep }
  if xs empty then:
    []
  else:
    xs tail sep prependToAll
    xs head prepend

// Gets the last element of a vector.
def last ([a] -> a):
  __last

// Character less than or equal.
def lec (Char Char -> Bool):
  __le_char

// Gets the length of a vector.
def length ([a] -> Int):
  __length

// Character less than.
def ltc (Char Char -> Bool):
  __lt_char

// Maps a function over a vector and concatenates the results.
def mapConcat ([a] (a -> [b]) -> [b]):
  map concat

// The maximum of two integers.
def max2 (Int Int -> Int):
  -> { a b }
  if a b > then: a else: b

// The maximum of three integers.
def max3 (Int Int Int -> Int):
  max2 max2

// The minimum of two integers.
def min2 (Int Int -> Int):
  -> { a b }
  if a b < then: a else: b

// The minimum of three integers.
def min3 (Int Int Int -> Int):
  min2 min2

// Character inequality.
def nec (Char Char -> Bool):
  __ne_char

// Floating-point negation.
def negf (Float -> Float):
  __neg_float

// Integer negation.
def negi (Int -> Int):
  __neg_int

// Writes a newline to standard output.
def newline (->):
  "\n" print

// Whether a floating-point number is odd.
def oddf (Float -> Bool):
  evenf !

// Whether an integer is odd.
def oddi (Int -> Bool):
  eveni !

// Opens a file for input.
def openInput ([Char] -> Handle):
  __open_in

// Opens a file for output.
def openOutput ([Char] -> Handle):
  __open_out

// Whether any element of a vector is true.
def or ([Bool] -> Bool):
  false {||} fold

// Constructs a pair.
def pair (a b -> (a & b)):
  __pair

// No-op.
def pass (->)
  {}

// Prepends a value to the head of a vector.
def prepend ([a] a -> [a]):
  -> { xs x }
  x vector xs cat

def prependToAll ([a] a -> [a]):
  -> { xs sep }
  if xs empty then:
    []
  else:
    xs tail sep prependToAll
    xs head prepend
    sep prepend

// Writes a string to standard output.
def print ([Char] ->):
  stdout __print

// Prints a Boolean.
def printb (Bool ->):
  showb print

// Prints a Boolean vector.
def printbv ([Bool] ->):
  showbv print

// Prints a string vector.
def printcvv ([[Char]] ->):
  showcvv print

// Prints a floating-point number.
def printf (Float ->):
  showf print

// Prints a floating-point vector.
def printfv ([Float] ->):
  showfv print

// Prints an integer.
def printi (Int ->):
  showi print

// Prints an integer vector.
def printiv ([Int] ->):
  showiv print

// The product of a vector of floating-point numbers.
def productf ([Float] -> Float):
  1.0 {*.} fold

// The product of a vector of integers.
def producti ([Int] -> Int):
  1 {*} fold

// Prints a string followed by a newline.
def say ([Char] ->):
  print newline

// Says a Boolean.
def sayb (Bool ->):
  printb newline

// Says a Boolean vector.
def saybv ([Bool] ->):
  printbv newline

// Says a string vector.
def saycvv ([[Char]] ->):
  printcvv newline

// Says a floating-point number.
def sayf (Float ->):
  printf newline

// Says a floating-point vector.
def sayfv ([Float] ->):
  printfv newline

// Says an integer.
def sayi (Int ->):
  printi newline

// Says an integer vector.
def sayiv ([Int] ->):
  printiv newline

// Sets the value at an index in a vector.
def set ([a] a Int -> [a]):
  __set

// Shows a Boolean as a string.
def showb (Bool -> [Char]):
  if then: "true"
  else: "false"

// Shows a Boolean vector as a string.
def showbv ([Bool] -> [Char]):
  {showb} showv

// Shows a string vector as a string.
def showcvv ([[Char]] -> [Char]):
  {id} showv

// Shows a floating-point number as a string.
def showf (Float -> [Char]):
  __show_float

// Shows a floating-point vector as a string.
def showfv ([Float] -> [Char]):
  {showf} showv

// Shows an integer as a string.
def showi (Int -> [Char]):
  __show_int

// Shows an integer vector as a string.
def showiv ([Int] -> [Char]):
  {showi} showv

// Shows a vector as a string.
def showv ([a] (a -> [Char]) -> [Char]):
  -> { v f }
  "[" v f map ", " join "]" cat cat

// Prints a space to standard output.
def space (->):
  " " print

// The standard error handle.
def stderr (-> Handle):
  __stderr

// The standard input handle.
def stdin (-> Handle):
  __stdin

// The standard output handle.
def stdout (-> Handle):
  __stdout

// The sum of a vector of floating-point numbers.
def sumf ([Float] -> Float):
  0.0 {+.} fold

// The sum of a vector of integers.
def sumi ([Int] -> Int):
  0 {+} fold

// Swaps two values. Useful for changing argument order when
// partially applying a function.
def swap (a b -> b a):
  -> { a b }
  b a

// Removes the first element of a vector.
def tail ([a] -> [a]):
  __tail

// Joins a vector of lines into a string.
def unlines ([[Char]] -> [Char]):
  "\n" join

// Wraps a value in a vector.
def vector (a -> [a]):
  __vector

// Bitwise OR.
def | (Int Int -> Int):
  __or_int

// Logical OR.
def || (Bool Bool -> Bool):
  __or_bool

// Bitwise NOT.
def ~ (Int -> Int):
  __not_int

// Zips two lists together as pairs.
def zip ([a] [b] -> [(a, b)]):
  {double} zipWith

// Zips two lists together with a function.
def zipWith ([a] [b] (a b -> c) -> [c]):
  -> { as bs f }
  if as empty  bs empty  || then:
    []
  else:
    as tail bs tail f zipWith
    as head bs head f apply21 prepend

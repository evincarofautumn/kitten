// Appends a value to the end of a vector.
define append @ a ([a] a -> [a]):
  vector cat

// The Cartesian product of two vectors.
define cartesian @ a b ([a] [b] -> [a & b]):
  \pair cartesianWith

// The Cartesian product of two vectors with a generalized
// tupling function.
define cartesianWith @ a b c ([a] [b] (a b -> c) -> [c]):
  -> xs ys function;
  forConcat (xs) -> x:
    for (ys) -> y:
      x y function apply

// Concatenates two vectors.
define cat @ a ([a] [a] -> [a]):
  __add_vector

// Operator alias for 'cat'.
infix_right 5 <>
define <> @ a ([a] [a] -> [a]):
  cat

// Concatenates a vector of vectors.
define concat @ a ([[a]] -> [a]):
  [] \<> foldl

// Lifts an impure function on values to one on vectors.
define each @ a ([a] (a ->) ->):
  -> xs f;
  option (xs head):
    f apply;
    xs tail f each

// Whether an element is present in a vector according to
// the given equality predicate.
define elem @ a ([a] a (a a -> bool) -> bool):
  -> xs x f;
  xs { x f apply } any

// Whether a character is present in a string.
define elemChar ([char] char -> bool):
  \eqChar elem

// Whether an integer is present in an integer vector.
define elemInt ([int] int -> bool):
  \= elem

// Whether two vectors are equal according to the given
// equality predicate.
define eqVector @ a ([a] [a] (a a -> bool) -> bool):
  -> xs ys eq;
  if (xs length != ys length):
    false
  else:
    xs ys eq zipWith and

// Filters a vector by a predicate.
define filter @ a ([a] (a -> bool) -> [a]):
  -> v f;
  option (v head) -> x:
    if (x f apply):
      v tail f filter
      x prepend
    else:
      v tail f filter
  else:
    []

// Finds the first element of a vector matching a predicate.
define find @ a ([a] (a -> bool) -> a?):
  filter head

// Folds elements of a vector right-associatively.
define foldr @ a b ([a] b (a b -> b) -> b):
  -> xs z k;
  option (xs last) -> x:
    (xs init) (x z k apply) k foldr
  else:
    z

// Right-associative non-empty vector fold.
define foldr1 @ a ([a] (a a -> a) -> a?):
  -> xs fn;
  option (xs last) -> x:
    (xs init) x fn foldr some
  else:
    none

define generateN @ a ((int -> a) int -> [a]):
  -> f size;
  from (0) unfold (size) -> index:
    index f apply;
    index + 1

// TODO (strager): Make this a compiler intrinsic.
define from_unfold__ @ a b (a int (a -> b a) -> [b]):
  -> z size f;
  if (size > 0):
    z f apply -> b a;
    (from (a) unfold (size - 1) (f)) b prepend
  else:
    []

// Unsafe right-associative non-empty vector fold.
define unsafeFoldr1 @ a ([a] (a a -> a) -> a):
  -> xs fn;
  xs init (xs unsafeLast) fn foldr

// Folds elements of a vector left-associatively.
define foldl @ a b ([b] a (a b -> a) -> a):
  -> xs z k;
  option (xs head) -> x:
    xs tail (z x k apply) k foldl
  else:
    z

// Left-associative non-empty vector fold.
define foldl1 @ a ([a] (a a -> a) -> a?):
  -> xs fn;
  option (xs head) -> x:
    xs tail x fn foldl some
  else:
    none

// Same as 'map' but prefix.
define for__ @ a b ([a] (a -> b) -> [b]):
  map

// Same as 'each' but prefix.
define forEach__ @ a ([a] (a ->) ->):
  each

// Same as 'mapConcat' but prefix.
define forConcat__ @ a b ([a] (a -> [b]) -> [b]):
  mapConcat

// Same as 'mapRange' but prefix.
define from_to__ @ a (a int int (a int -> a) -> a):
  mapRange

// Unsafe left-associative non-empty vector fold.
define unsafeFoldl1 @ a ([a] (a a -> a) -> a):
  -> xs fn;
  xs tail (xs unsafeHead) fn foldl

// Gets multiple elements of a vector.
define getAll @ a ([a] [int] -> [a?]):
  -> xs indices;
  indices {(xs .)} map

// Gets the first element of a vector.
define head @ a ([a] -> a?):
  (.(0))

// Splits a vector into its head and tail.
define headTail @ a ([a] -> a? [a]):
  \head \tail bothTo

// Unsafely removes the last element of a vector.
define init @ a ([a] -> [a]):
  __init

// Inserts a value at each possible index in a vector; given
// a value n and a vector xs, generates a matrix with n on
// the main diagonal and xs wrapped to the remainder.
define insertEverywhere @ a ([a] a -> [[a]]):
  -> xs n;
  option (xs head) -> x:
    (xs tail) n insertEverywhere
    {x prepend} map
    (xs n prepend)
    prepend
  else:
    [[n]]

define insert @ a ([a] a (a a -> bool) -> [a]):
  -> xs n lt;
  option (xs head) -> x:
    if (x n lt apply):
      (xs tail) n lt insert
      x prepend
    else:
      xs n prepend
  else:
    [n]

// Intersperses a value between the values of a vector.
define intersperse @ a ([a] a -> [a]):
  -> xs sep;
  option (xs head) -> x:
    xs tail sep prependToAll
    x prepend
  else:
    []

// Whether a vector is empty.
define isEmpty @ a ([a] -> bool):
  length (= 0)

// Joins a vector with a separator.
define join @ a ([[a]] [a] -> [a]):
  intersperse concat

// Keeps the first n elements of a vector, tossing the rest.
define keep @ a ([a] int -> [a]):
  -> xs n;
  if (n <= 0):
    []
  else:
    option (xs head) -> x:
      xs tail (n - 1) keep
      x prepend
    else:
      []

// Keeps elements of a vector while a predicate holds.
define keepWhile @ a ([a] (a -> bool) -> [a]):
  -> xs f;
  []
  option (xs head) -> x:
    if (x f apply):
      drop
      xs tail f keepWhile
      x prepend

// Gets the last element of a vector.
define last @ a ([a] -> a?):
  -> xs;
  xs.(xs length - 1)

// Gets the length of a vector.
define length @ a ([a] -> int):
  __length

// Looks up a value in an association list by an equality predicate.
define lookUp @ a b ([a & b] a (a a -> bool) -> b?):
  -> key eq;
  { first key eq apply } find
  \rest liftOption

// Lifts a function on values to a function on vectors.
define map @ a b ([a] (a -> b) -> [b]):
  -> xs f;
  option (xs head):
    f apply vector
    (xs tail) f map
    cat
  else:
    []

// Maps a function over a vector and concatenates the results.
define mapConcat @ a b ([a] (a -> [b]) -> [b]):
  map concat

// Maps a function over part of a vector.
define mapFrom @ a ([a] (a -> a) int -> [a]):
  -> vec function offset;
  if (vec isEmpty || offset >= vec length):
    vec
  else:
    vec(offset .~ function)
    function (offset + 1) mapFrom

// Maps a function over a value for each integer in a range.
define mapRange @ a (a int int (a int -> a) -> a):
  -> value start end function;
  if (start <= end):
    value start function apply;
    (start + 1) end function mapRange
  else:
    value

// Generates all permutations of a vector.
define permutations @ a ([a] -> [[a]]):
  [[]] { -> x; {x insertEverywhere} mapConcat } foldl

// Prepends a value to the head of a vector.
define prepend @ a ([a] a -> [a]):
  -> xs x;
  x vector xs cat

define prependToAll @ a ([a] a -> [a]):
  -> xs sep;
  option (xs head) -> x:
    xs tail sep prependToAll
    x prepend
    sep prepend
  else:
    []

// Produces a vector with some number of copies of a value.
define replicate @ a (a int -> [a]):
  -> value count;
  if (count <= 0):
    []
  else:
    value (count - 1) replicate
    value prepend

// Reverses a vector.
define reverse @ a ([a] -> [a]):
  -> xs;
  option (xs head) -> x:
    xs tail reverse
    x append
  else:
    []

// Produce a list of fold-left results
define scanl @ a b ([b] a (a b -> a) -> [a]):
  -> xs z k;
  xs z k scanlRest z prepend

// Scan left with vector head as accumulator
define scanl1 @ a ([a] (a a -> a) -> [a]):
  -> xs k;
  xs tail (xs unsafeHead) k scanl

// Scan fold of remaining elements
define scanlRest @ a b ([b] a (a b -> a) -> [a]):
  -> xs z k;
  option (xs head) -> x:
    z x k apply -> q;
    xs tail q k scanlRest
    q prepend
  else:
    []

// Produce a list of fold-right results
define scanr @ a b ([a] b (a b -> b) -> [b]):
  -> xs z k;
  option (xs head) -> x:
    (xs tail) z k scanr dup unsafeHead
    x swap k apply
    prepend
  else:
    [z]

// Scan right with vector last as accumulator
define scanr1 @ a ([a] (a a -> a) -> [a]):
  -> xs k;
  xs init (xs unsafeLast) k scanr

define sort @ a ([a] (a a -> bool) -> [a]):
  -> lt;
  [] {lt insert} foldl

define span @ a ([a] (a -> bool) -> [a] [a]):
  -> xs f;
  xs f keepWhile
  xs f tossWhile

// Splits a vector into two parts at the given index.
define splitAt @ a ([a] int -> [a] [a]):
  -> xs n;
  xs n keep
  xs n toss

// Unsafely removes the first element of a vector.
define tail @ a ([a] -> [a]):
  __tail

// Tosses the first n elements of a vector, keeping the rest.
define toss @ a ([a] int -> [a]):
  -> xs n;
  if (n <= 0 || xs isEmpty):
    xs
  else:
    xs tail (n - 1) toss

// Tosses elements of a vector while a predicate holds.
define tossWhile @ a ([a] (a -> bool) -> [a]):
  -> xs f;
  xs
  option (xs head) -> x:
    if (x f apply):
      tail f tossWhile

// Transposes the rows and columns of a 2D vector.
define transpose @ a ([[a]] -> [[a]]):
  -> xss;
  if (xss isEmpty):
    []
  else:
    if (xss unsafeHead isEmpty):
      xss tail transpose
    else:
      xss unsafeHeadTail -> xs xss;
      xs unsafeHeadTail -> x xs;
      ((xss \tail map) xs prepend) transpose
      (xss \unsafeHead map) x prepend
      prepend

// Strips duplicate elements from a vector according the
// given equality predicate.
define unique @ a ([a] (a a -> bool) -> [a]):
  -> xs eq;
  option (xs head) -> x:
    (xs tail {x (eq apply) not} filter) eq unique
    x prepend
  else:
    []

define unsafeHead @ a ([a] -> a):
  head fromSome

define unsafeHeadTail @ a ([a] -> a [a]):
  \unsafeHead \tail bothTo

define unsafeLast @ a ([a] -> a):
  last fromSome

// Wraps a value in a vector.
define vector @ a (a -> [a]):
  -> x; [x]

// Zips two lists together as pairs.
define zip @ a b ([a] [b] -> [a & b]):
  \pair zipWith

// Zips two lists together with a function.
define zipWith @ a b c ([a] [b] (a b -> c) -> [c]):
  -> as bs f;
  []
  option (as head) -> a:
    option (bs head) -> b:
      drop
      (as tail) (bs tail) f zipWith
      a b f apply; prepend

// Gets an element of a vector.
define . @ a ([a] int -> a?):
  __get

// Unsafely gets an element of a vector.
define ! @ a ([a] int -> a):
  (.) fromSome

// Sets the value at an index in a vector.
define .= @ a ([a] int a -> [a]):
  __set

// Maps a function over an element of a vector.
define .~ @ a ([a] int (a -> a) -> [a]):
  -> vec offset function;
  option (vec.(offset)):
    function apply -> value;
    vec(offset .= value)
  else:
    vec

// Gets a value from a 2D vector.
define .. @ a ([[a]] (int & int) -> a?):
  -> p;
  (. p first) {(. p rest)} bindOption

// Unsafely gets a value from a 2D vector.
define !! @ a ([[a]] (int & int) -> a):
  -> p;
  (! p first) (! p rest)

// Sets a value in a 2D vector.
define !!= @ a ([[a]] (int & int) a -> [[a]]):
  -> p x;
  p first .~: p rest .= x
